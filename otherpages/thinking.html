<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>愛の妖精ぱらんてぃんの極まりないズサン運営救世おまんこ</title>
</head>
<body>
    <center>
        <h1>考えたこととかのメモ</h1>
    <br>
    ここでは足りない頭で考えたこととかをメモしておこうと思います. 主に普段の日記に書くにはやや長い内容を書きます. <br>
    <h2>目次</h2>
    <a href="#20251021_1">Twitterで「現代の左翼運動は金持ちのお遊びに見えるといわれるのはなぜだろう」という発言を見た. (2025/10/21)</a><br>
    <a href="#20251021_2">愚鈍の役割について (2025/10/21)</a><br>
    <a href="#20251025_1">minecraftのmod制作にAIが利用できるかという話(2025/10/25)</a><br>
    <a href="#20251029_1">minecraftの攻撃ダメージの話(2025/10/29)</a><br>
    </center>

    <ul>
        <li><a id="20251021_1">Twitterで「現代の左翼運動は金持ちのお遊びに見えるといわれるのはなぜだろう」という発言を見た. (2025/10/21)</a></li>
            <ul>
                <li>しかし, そもそも左翼運動が完全に労働者階級によって担われた例が歴史上どれほどあっただろうか. </li>
                <li>確かに, 社会主義革命の多くは労働者や農民も関わってはいた. しかし革命の中枢は必ずしもそうではない. 
                レーニンは中流階級, 毛沢東は地主の子, ゲバラもブルジョア, ポルポトに至っては王族とつながりのある名士の家である. </li>
                <li>この現象はそもそも, マルクス主義が難解であり, 革命家となるためにはある程度の教育を受けている必要があることに起因する.
                    実際これについては「共産党宣言」でも説明されており, 労働者の革命を支える, 知識を持った革命前衛が必要であるとされている. 
                    つまり革命家であるためには, ある程度の金持ちの家に生まれ, そして十分な教育を受けていることが必要条件となるのである. </li>
                <li>日本で起きた左翼運動も, 特に60年代から70年代にかけての新左翼運動にはこの側面が非常に強く表れている. 
                大学進学率が今と比べ非常に低かった当時, アルバイトと勉学に忙殺されるわけでもなくデモだ火炎瓶だ腹腹時計だに没頭できた学生はどのような階級だろうか？
                ある程度裕福な家の出身者である. 彼らは現実から目を背け, 妄想の中の労働者のみに語り掛け, 飛行機を乗っ取りホテルに立てこもり, 本来の労働者からの支持を失った. 
                これを新左翼運動の失敗と断ずるのは簡単だが, むしろこれは革命前衛というシステムそのものに欠陥があるのではないかと考える. </li>
                <li>左翼運動がお遊びであるかは別として, 少なくとも金持ちのものであったのは事実である, これからもしばらくの間はそうだろう. 
                    少なくとも「労働者による革命」などというお題目は早々に捨て去ってしまい, 「賢い俺たちがお前らワープアを地獄の底から引きずり出してやるからな」くらいの気概でいるのが吉だろう. </li>
            </ul>
        <li><a id="20251021_2">愚鈍の役割について (2025/10/21)</a></li>
            <ul>
                <li>1984という小説がある. まあ有名だし, 名前も聞いたことないという人はいないだろう. この小説には"Ignorance is strength"というフレーズが登場する. 
                    直訳すると「無知は力なり」である.  </li>
                <li>前項で述べた, マルクス主義の難解による左翼運動の独占性との対比にもなっているのであるが, 昨今のネット世論を騒がせている「愛国心」の動き. これについて考える. </li>
                <li>さて, 臆せずに名前を出すが参政党や日本保守党といった日本のネオナチ運動の支持者に共通するカジュアルなゼノフォビア. 
                    昔懐かしぜロ年代の在特会を彷彿とさせるが, 手法はより洗練されている. ただここではその洗練ではなく, ゼノフォビアのほうに着目していきたい. </li>
                <li>ネオナチ政党の間に共有されているのは, 理論ではなく「お気持ち」である. これは前項の左翼運動との最大の違いだろう. 
                    つまり, 革命前衛を必要とした左翼運動と違い, 「お気持ち」さえ共有していれば誰でも「愛国者」であり, 誰でも「革命家」である. </li>
                <li>では, なぜこのような運動が最近になっていきなり浮上したのだろう. 言葉は悪いが, 「バカ」に厳しい世の中になったからだと私は考える. </li>
                <li>かつて, 愚鈍な人間は今ほど肩身が狭かったわけではない. 彼らを救ったのは宗教であった. 宗教は「愚鈍」を「敬虔」と言い換えた. 
                    神に純粋な祈りをささげるのであれば, 愚鈍であることは大した問題ではなかった. 場合によっては「愚直」として賞賛すらされた. </li>
                <li>無神論の国や世俗国家でもそれは例外ではなかった. 例えばソビエト連邦では建前上, 宗教が否定された. では愚鈍な人が生きづらかったかというと, そうではない. 
                    スタハノフ運動のような大衆動員によって, 愚鈍には「勤勉」という別名が付与された. バカでもバカなりに手を動かせば, それは評価されるということである. 
                    もちろんそれは建前であったかもしれないが, 愚鈍を生きづらさから解放してくれるという意味では宗教と大きな差はなかった. </li>
                <li>では現代日本はどうだろうか. 日本人が無宗教であるというのは否定されて久しいが, 宗教に心の底から救いを求めている日本人は多くないだろう. 
                    その一方でワーキングプアをはじめとした社会問題が濃い霧のように立ち込めていて, 勤勉に救済を求めるのも難しい. 技術は高度化し, 
                    求められる情報処理能力だけはますます大きくなっていく. 愚鈍のレトリックが消失し, 愚鈍は「愚鈍」として評価される社会である. </li>
                <li>このとき, 「敬虔」や「勤勉」に救済を得ていた愚鈍はどういった行動をとるか. 換言の衣を脱がされた以上, ちっぽけなプライドを守るには今持っているものを誇るしかない. 
                    そして誰しも生まれた時点で国から与えられるものがある. 国籍である. 何を失っても, 国籍だけは手元にある. 努力する体力すら失われた愚鈍にとって, プライドを守る最後の砦である. </li>
                <li>ネオナチ政党はこういった層をうまく取り込んだといえるだろう. かつては宗教やワーカホリックが役割を与えていた層に, 今度は「愛国者」という役割を与えた. 
                    「愛国者」は, 国籍が愚鈍が共通して持つ属性の中で最大公約数的であるという点でクリティカルである. 例えば「絵が描ける」「特定地域に住む」「きのこの山を好む」はクリティカルではない. 
                    なぜなら絵が描けない愚鈍も, 特定地域に縁がない愚鈍も, たけのこの里を好む愚鈍もいるからである. しかし国籍は誰もが持っている, いわば最大公約数の属性である. 
                    同値類的にまとまった集団は連帯感を共有するため強く, そして国籍のプライドは人々の同値関係の中で最も規模の大きい集団を生成できる. </li>
                <li>ここで少し話はそれるが, こういった愚鈍をターゲットにした政党はネオナチ政党が初めてというわけではない. れいわ新選組も発想としては非常に近いと考えている. 
                    しかし彼らは明らかにネオナチと比べて伸びが悪い. それは彼らが「生」という, 商集合が単一の要素しかないような同値関係を主張したからである. 
                    例えば「自分は太陽系に住んでいるなあ」と実感することは日常でそうそうない. なぜなら太陽系の外から来た人に会うことはないからである(もしこのページの読者で太陽系外から来たという人がいたらごめんなさい). 
                    しかし, 例えばガラス張りの部屋に閉じ込められていて, 外を人が歩いていたら, 自分はガラス張りの部屋に閉じ込められていると大いに実感するだろう. 何が言いたいかというと, 
                    人は自分の属する集合と属さない集合の両方を観測したときに, 初めて自分が集合に属していると実感する. 「生きているだけで尊い」は, したがってスローガンとして適切ではない. 
                    なぜなら生きていない人間を観測することはめったにないからである. 自分が今「生きている人間」の構成員だと実感するタイミングは, 日常生活を送るうえでほとんどないだろう. 
                    国籍はそうではない. 外国籍の人と会話することは今や全く珍しくない. 外国籍の人間を認識することで, かえって自分の国籍が意識され, 属性として有効になるのである. </li>
                <li>愚鈍にこのような「愛国者」の役割を与える隙を作ってしまったこと, これは右派・左派問わず論壇全体で大いに反省すべき事案だろう. これは予期しえたことだったからである. </li>
                <li>無知は力なり. 社会に役割を奪われた愚鈍たちの復讐が始まる. </li>
            </ul>
        <li><a id="20251025_1">minecraftのmod制作に生成AIが利用できるかという話(2025/10/25)</a></li>
            <ul>
                <li>minecraftのmodの開発にAI(ChatGPT)を利用してみて, どれくらい使えるかを少し検証してみたという話. 
                    本来ならQiitaかzennにでも書くべき話なのかもしれないが, そんな技術的に込み入った話でもないのでここに書く. </li>
                <li>まず軽く前提知識の話. Minecraftのmod開発はJava(まれにKotlin)で行われる. Minecraft Forgeと呼ばれる有志開発のAPI群があり, 
                    Forgeのクラスをimportして処理を行うのが基本である(最近ではFabricやNeoForgeなどの異なるAPIも存在する). </li>
                <li><a href="../benkyo.html">勉強</a>の項目で触れた通り, 筆者の使用言語はC++であり, Javaの知識はあまりない. 
                    ただしC++とJavaは似た文法を持っているので頑張ればある程度読める, のレベルである. </li>
                <li>ゼロからmodを作るのはかなり面倒なので, 筆者はよく<a href="https://mcreator.net/">MCreator</a>と呼ばれるフリーのノーコード開発ソフトで大枠を作り, 
                    このソフトで手が届かない部分をVScodeでシコシコ編集するという開発体制をとっているが, 実装したい処理がどのクラスのどのメソッドに関連しているのかというのは, 
                    これはある程度技術的な蓄積が必要な部分で, まだ初学者の私は苦労することが多い. <a href="https://docs.minecraftforge.net/en/1.20.1/">Forgeの公式ドキュメント</a>やStackOverflowと格闘する日々である. </li>
                <li>本題に入る. 今回どのような処理の実装をChatGPTにやらせるかというと「コマンド権限の変更」処理である. </li>
                <li>コマンドとはminecraftにおける「チート機能」のことで, サーバーでは管理者以外は使用不能になっているのが基本であり, またシングルプレイでもサバイバルモードではオフになっているのがデフォである. 
                    このチート機能の権限を書き換えるような処理を実装してみようというのが今回の目標である. はっきり言って技術者倫理に反した荒らしみたいな処理であるが, ホラー系のmodやPVPのmodでは割とありがちである. 
                    おそらく上級者の方ならサッと書けてしまう処理だろうが, Forge初心者とAIでこの処理が書けるだろうかという話である. なお筆者はまだForge初心者であるため, 用語や解説に不正確な点が多数あるだろうがご容赦願いたい. </li>
                <li>より具体的な要件・処理内容は次のようになる. まずMinecraftのバージョンとしては1.20.1, Forgeのバージョンは1.20.1の47.4.0である. 実現したい処理としては,「コマンド権限が0のプレーヤーが特定のワードをチャット欄に打ち込むと, 
                    コマンド権限レベル2以上を取得する」という流れである. コマンド権限とはチートを使用できる権限のことで, Java Editionにおいてコマンド権限レベル2とは基本的なチート操作がほぼすべて可能であることを意味する. </li>
                <li>特定のワード(今回は管理者権限の要求ということで"givemeauth"とした)がチャット欄に打ち込まれたことを検知する処理は面倒なうえに本質的でもないのでMCreatorで組み, 検知後の処理を実装した. </li>
                <li>そもそもプレーヤーごとのコマンド権限がどこに格納されているのか知る必要があったため, 「Minecraft forgeにおいてコマンド権限はPlayerクラスにメンバ変数として格納されていますか？また格納されている場合はどの変数に格納されていますか？」
                    という質問を行った. 返答は結構長かったのでまとめると, </li>
                    <ul>
                        <li>サーバーにおけるプレーヤーの実装はPlayerクラスではなく, そのサブクラスであるServerPlayerに実装されている. </li>
                        <li>ただしServerPlayerクラスは直接のメンバ変数としてコマンド権限を格納していない. </li>
                        <li>実際にコマンド権限を取得する際に行っている処理は, まず親クラスであるEntityクラスのメソッドであるcreateCommandSourceStackを呼び出す. 
                            このメソッドはServerPlayerクラス(もっと言えば親クラスであるEntityクラス)のオブジェクトからCommandSourceStackクラスのオブジェクトを生成するメソッドである. </li>
                        <li>このCommandSourceStackクラスのメンバ変数として, 権限レベルであるpermissionLevelが変数として格納されている. </li>
                        <li>この変数はprivateなので, アクセスする際にはServerPlayerのメソッドgetPermissionLevelを利用している. </li>
                        <li>このメソッドはServerPlayerからメソッドgetGameProfileを用いて生成されるオブジェクトGameProfileを引数に取る. </li>
                        <li>このメソッドが外部のjsonファイルから権限情報を読み込み, 判定を行っている. </li>
                    </ul>
                    であった. </li>
                <li>この情報の正誤は実装時に検証するとして, 続いて「Minecraft Forge 1.20.1でプレイヤーのコマンド権限を動的に変更したいと考えております. 適切なメソッドを教えてください.」
                    という質問を行った. 3つほど方法が提案されたが, 実際に実装に用いた手法の提案は以下のような内容であった. 
                    <ul>
                        <li>PlayerListクラスにはコマンド権限の付与・剥奪処理を行うaddOp/removeOpメソッドが定義されている. </li>
                        <li>PlayerListオブジェクトはServerPlayerのメソッドgetPlayerListによって生成される. </li>
                        <li>またServerPlayerのメソッドgetGameProfileから対応するPlayerのGameProfileオブジェクトを生成する. </li>
                        <li>addOpメソッドを用いて権限を再設定する. ただしこのメソッドは引数としてOpEntry型をとるので, このオブジェクトをnewで生成してaddOpメソッドを適用する. </li>
                        <li>importするクラスはcom.mojang.authlib.GameProfile, net.minecraft.server.level.ServerPlayer, net.minecraft.server.players.PlayerList, net.minecraft.server.players.OpEntryである. </li>
                    </ul>
                    であった. </li>
                <li>さて, 実際にはこの実装はうまくいかない. そもそもForge 1.20.1のPlayerListクラスにaddOp/removeOpメソッドは存在しない. おそらく過去のバージョンの情報を学習してしまったものと考えられる. 
                    さらにOpEntryクラスも存在しない. これを指摘すると「お前が十分に探してないだけじゃないの～？(意訳)」などとごね始めたが, とりあえず存在しないことを認識させたので
                    「今までの議論をもとに, Minecraft Forge 1.20.1でプレイヤーのコマンド権限を動的に変更するメソッドを再度提案してください.」とお願いしたところ, OperatorEntryなるクラスが実在するものとして実装コードを提案してきたので, 
                    これ以上は困難と判断し, ここからは自力で実装することにした. </li>
                <li>ここまでだとチャッピー君はいい加減なことばっかし言ってるように見えるが, 少なくとも前半のコマンド権限の構造については(多少不正確なところはあれど)大きく間違ったことは言っていない. 
                    したがってForge開発においては, クラスの構造を把握する用途なら有用であるといえるだろう. しかし実装にはまだ少し難があるように感じた. </li>
                <li>さて, 肝心の実装である. 確かにPlayerListクラスにaddOp/removeOpメソッドは存在しないが, 代わりにop/deopメソッドが存在する. 
                    これはGameProfile型のオブジェクトを引数にとり, 対応するServerPlayerにコマンド権限を付与するメソッドである. したがって実装の流れとしては以下のようになる. 
                    <ul>
                        <li>com.mojang.authlib.GameProfile, net.minecraft.server.level.ServerPlayer, net.minecraft.server.players.PlayerListをimportし, 
                            voidを返り値(つまり何も返さない)としてsetPlayerPermissionLevel(ServerPlayer player) という名前でメソッドを定義する(この名前はわかりやすければなんでもいい). </li>
                        <li>PlayerList型のオブジェクトをplayerのメンバ変数であるserverのメソッドgetPlayerListで生成する. </li>
                        <li>GameProfile型のオブジェクトをplayerのメソッドgetGameProfileで生成する. </li>
                        <li>生成したPlayerList型オブジェクトのopメソッドにGameProfileオブジェクトを渡し, コマンド権限を付与する. </li>
                        <li>最後にこのsetPlayerPermissionLevelを文字列認識後の処理に組み込む. MCreatorのコード生成は常にPlayer型でプレーヤーの情報を扱うので, 
                            この関数にオブジェクトを渡す際はServerPlayer型にキャストする. </li>
                    </ul>
                    これで実際にコマンド権限が変更されるか確認したところ, チートオフのワールドでもgivemeauthと打ち込むことでコマンドが解禁されることが確認された. 
                    マルチプレイでの挙動は未検証である. これは筆者にminecraftをともにプレイする友人がいないことに起因する. 
                </li>
                <li>結論として, minecraftのmodを完全に生成AIがコーディング(いわゆるバイブコーディング)するのはまだ厳しいだろうと感じた. しかしクラスの構造や関係を把握するのにはかなり有用であったので, 
                    「Javaは最低限わかるけどForgeの知識はない」レベルの層には役に立つのではないかと感じた. </li>
            </ul>
        <li><a id="20251029_1">minecraftの攻撃ダメージの話(2025/10/29)</a></li>
        <ul>
            <li>はい, 寝る前にジャムおじさんのお話聞こうね. 今回はminecraftにおいて, 1回の攻撃でどれだけ大きなダメージを与えられるかという話である. </li>
            <li>小学生のころ, 誰しも一度はダイヤの剣にめっちゃ強いエンチャントをつけてエンダードラゴンを殴ったりしたものだろう. これをまじめに検証しようという話である. </li>
            <li>なお1.21以降ではメイスが, また本項執筆時点ではスピアというスピード依存武器の追加が発表されているが, ひとまずJava版1.20.1での検証としたい. またそもそもminecraftには思い通りにダメージを与える/damageコマンドがあるが, 野暮ったいので禁止カードとする. 
                なお検証には<a href="https://www.curseforge.com/minecraft/mc-mods/mmmmmmmmmmmm">こちらのmod</a>を使用している. </li>
            <li>まず最も簡単に思いつくものとして, ネザライトの剣にエンチャントで鋭さ5を付与してみる. 一撃で与えられるダメージは11ダメージ. クリティカルを当ててもその約1.5倍の15ダメージとなった. 
                普通のプレイにはこれで申し分ないだろう. </li>
            <li>ではここからはコマンドを使う. コマンドを使って付与できる最大のレベルは255である(昔は32767だった気がするがいつごろからか255になっていた). 鋭さ255のネザライトの剣で殴ってみよう. </li>
            <li>ダメージは通常時で136, クリティカルで140となった. エンダードラゴンなら2発, ウィザーなら3発, ウォーデンなら4発である. ぶっ壊れ性能といっていいだろう. こんなものがお出しされたらゲームバランスは崩壊である. </li>
            <li>なお純粋な攻撃力なら斧のほうが強いが, ここまでくると剣も斧も大差はない. </li>
            <li>マインクラフトには攻撃力を上昇させる手段がもう一つある. 攻撃力上昇のポーションである. これを最大値の255までつけて前述のネザライトの剣255で殴ったところ, 
                ダメージは通常で904, クリティカルで1292ダメージとなった. バニラのモブはすべてワンパンである. </li>
            <li>さて, minecraftの公式wikiを見てみよう. <a href="https://ja.minecraft.wiki/w/%E3%83%80%E3%83%A1%E3%83%BC%E3%82%B8">ダメージの項</a>にはダメージの計算機が載せられている. この計算機で先ほどの条件を計算すると, 
                極端な条件では若干ずれるが, 大体正しい値が出る. </li>
            <li>実はminecraftで一撃で与えられる「近接攻撃の」ダメージの値には上限がある. 細かい話は多分色々調べれば出てくるが, 近接攻撃で与えられる最大のダメージは3072ダメージ(ハート1536個分)である. 
                何らかの方法(mod等)で数値上はこれ以上の攻撃力をもつ武器を作ったとしても, 3072ダメージを超えるダメージは与えられない. 正確には近接攻撃が2048ダメージで, それにクリティカル倍率1.5倍をのっけたのが3072ダメージである. </li>
            <li>ところが「近接攻撃の」と強調した通り, 近接攻撃に限らなければさらに大きなダメージを与えることは可能である. なんでそんなことする必要があるんですかという疑問はさておき, その方法を見てみる. minecraftには直接殴る以外にもいくつかダメージを与える方法がある. 
                例えば矢を撃ったり, ベッドを爆発させたり, ポーション効果でダメージを与えたり. 重要なのはこれらの攻撃のダメージ計算には先述のダメージ上限は適用されないということである. </li>
            <li>例としてコマンドで「即時ダメージのスプラッシュポーション」をレベル28で作成する. こちらのポーションによるダメージを測定したところ, 与ダメージ量は驚異の1,610,612,736ダメージ(2^30+2^29ダメージ)となった. 
                即時ダメージのポーションのレベルからの計算式は公式wikiにない(探せばあるかも)ためこれは推測でしかないが, 即時ダメージレベル1,2はしょーもないことを考えると, おそらく指数関数的にダメージ量が増加していると考えられる. 
                なおポーション効果は(即時ダメージに限らず)レベルが32の剰余で計算されるが, 即時ダメージに関しては29~31ではダメージが0であった. おそらく28の16億ダメージ以上は0となるように設定されているのだろう. </li>
            <li>じゃあ16億ダメージがminecraftで与えられるダメージですねということで話を終えてもいいのだが, ここは救世おまんこである. もう少し考察してみよう. </li>
            <li>16億ダメージでポーション効果が打ち切られている理由を考えてみる. Javaの符号付きint型整数は32bitで定義されているので最大値はおなじみの21億である. ダメージ値がint型で実装されている場合, これ以上先に進むとオーバーフローしてしまうため打ち切られていると考えるのが自然である. </li>
            <li>ところが, 話はそんなに簡単ではない. Forgeのダメージに関する実装を見てみると, どうやらminecraftにおいてダメージ量はintではなくfloatで扱われている. まあ小数ダメージもあったりするので当たり前といえば当たり前である. </li>
            <li>実際, 例えばLivingEntityクラスのhurtメソッドはダメージ量の引値としてfloat型をとっている. つまり理屈上は32bitの浮動小数点である3.4E+38がダメージの最大値となる. </li>
            <li>実はバニラのminecraftおいてこの量のダメージが与えられるイベントは存在していて, 皆さんも一度は使ったことがあるだろう. /killコマンドである. </li>
            <li>KillCommandのクラスを見てみると, 実装であるKillメソッドが存在するが, このメソッドの実装を辿ってみると極めて単純で, 要は受け取ったエンティティにfloat.MAX_VALUEを与えている. 
                つまりどうでも淫夢ではあるが, killコマンドの実態はエンティティに3.4E+38ダメージを与えることだったのである. なおLivingAttackEventはcancelableなので, 
                この仕様を利用(悪用？)すればkillコマンドを使っても死なないエンティティを作ることができる. 実際前に作ったことがある. </li>
            <li>さて, float型なのに16億で切られている理由として考えられるのは精度の問題だろう. 浮動小数点演算は絶対値が極端に大きい値や小さい値では精度が悪化する. 単精度浮動小数点で表記できる数は, 10進法表記で1の位までの精度を要求した場合, 
                一般の実装では100万程度まで保証され, それ以上になると小さな位は大雑把になる. つまり件の16億ダメージは浮動小数点ではもうだいぶ大雑把な値となっている. 2進数表記で意外ときれいな値になったのも小さい桁が切り捨てられていたからなのだろう. </li>
            <li>よし, お話終わり. 寝て良いよ. </li>
        </ul>
    </ul>
    
    <br>
    <center>
        <a href="../others.html">もどる</a>
    </center>
</body>
</html>
